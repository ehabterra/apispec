package parser

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"regexp"
	"strings"

	"github.com/ehabterra/swagen"
)

// --- Chi-specific constants and patterns ---

var chiParamRe = regexp.MustCompile(`{([a-zA-Z0-9_]+)}`)

func convertChiPathToOpenAPI(path string) string {
	return chiParamRe.ReplaceAllString(path, `{$1}`)
}

// --- ChiCallExprStrategy ---

type ChiCallExprStrategy struct{}

func (s *ChiCallExprStrategy) TryParse(node ast.Node, fset *token.FileSet, funcMap map[string]*ast.FuncDecl, goFiles []*ast.File, next RouteStrategy, info *types.Info) (*swagen.ParsedRoute, bool) {
	call, ok := node.(*ast.CallExpr)
	if !ok {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	se, ok := call.Fun.(*ast.SelectorExpr)
	if !ok {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}

	method := se.Sel.Name
	if !isChiHTTPMethod(method) {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}

	if len(call.Args) < 2 {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	pathLit, ok := call.Args[0].(*ast.BasicLit)
	if !ok || pathLit.Kind != token.STRING {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	path := strings.Trim(pathLit.Value, "\"")

	handlerName := getHandlerName(call.Args[1])
	if handlerName == "" {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	handlerFunc := funcMap[handlerName]

	builder := NewParsedRouteBuilder(info)
	route := builder.Method(method).
		Path(convertChiPathToOpenAPI(path)).
		Handler(handlerName, handlerFunc).
		ChiRequestBody(handlerFunc).
		ChiResponses(handlerFunc, goFiles).
		Position(fset, call.Pos()).
		Build()

	return &route, true
}

// --- ChiParser with Event System and Chain of Responsibility ---

type ChiParser struct {
	chain     *StrategyChain
	listeners []EventListener
	info      *types.Info // for type resolution
}

func NewChiParserWithTypes(strategies []RouteStrategy, info *types.Info, listeners ...EventListener) *ChiParser {
	return &ChiParser{
		chain:     &StrategyChain{strategies: strategies},
		listeners: listeners,
		info:      info,
	}
}

func DefaultChiParserWithTypes(info *types.Info) *ChiParser {
	return NewChiParserWithTypes(
		[]RouteStrategy{
			&ChiCallExprStrategy{},
			// Add more Chi-specific strategies here
		},
		info,
	)
}

func (p *ChiParser) AddListener(listener EventListener) {
	p.listeners = append(p.listeners, listener)
}

func (p *ChiParser) Parse(fset *token.FileSet, files []*ast.File) ([]swagen.ParsedRoute, error) {
	funcMap := buildFuncMap(files)
	var routes []swagen.ParsedRoute

	for _, file := range files {
		ast.Inspect(file, func(n ast.Node) bool {
			if route, ok := p.chain.TryParse(n, fset, funcMap, files, nil, p.info); ok {
				routes = append(routes, *route)
				for _, l := range p.listeners {
					l(EventRouteFound, route)
				}
				return false
			}
			return true
		})
	}
	return routes, nil
}

// --- Chi-specific helpers ---

func isChiHTTPMethod(method string) bool {
	switch method {
	case "Get", "Post", "Put", "Delete", "Patch", "Options", "Head":
		return true
	}
	return false
}

// extractChiRequestBodyType inspects a function body to find the type of a bound variable.
// This is specific to Chi's binding methods.
func extractChiRequestBodyType(fn *ast.FuncDecl) string {
	if fn.Body == nil {
		return ""
	}

	var boundVarName string
	ast.Inspect(fn.Body, func(n ast.Node) bool {
		if boundVarName != "" {
			return false
		}
		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}
		se, ok := call.Fun.(*ast.SelectorExpr)
		if !ok || !isChiBindingMethod(se.Sel.Name) {
			return true
		}

		if len(call.Args) > 0 {
			if unary, ok := call.Args[0].(*ast.UnaryExpr); ok && unary.Op == token.AND {
				if ident, ok := unary.X.(*ast.Ident); ok {
					boundVarName = ident.Name
					return false
				}
			}
		}
		return true
	})

	if boundVarName == "" {
		return ""
	}

	var varType string
	ast.Inspect(fn.Body, func(n ast.Node) bool {
		if varType != "" {
			return false
		}
		decl, ok := n.(*ast.DeclStmt)
		if !ok {
			return true
		}
		genDecl, ok := decl.Decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.VAR {
			return true
		}
		for _, spec := range genDecl.Specs {
			if vspec, ok := spec.(*ast.ValueSpec); ok {
				for _, name := range vspec.Names {
					if name.Name == boundVarName {
						if typeName := getTypeName(vspec.Type); typeName != "" {
							varType = typeName
							return false
						}
					}
				}
			}
		}
		return true
	})

	return varType
}

// isChiBindingMethod checks if a function name is a common Chi binding method.
func isChiBindingMethod(name string) bool {
	switch name {
	case "Decode", "Bind", "ParseForm", "ParseMultipartForm":
		return true
	}
	return false
}

// extractChiResponseTypes extracts response types from Chi handler functions
func extractChiResponseTypes(fn *ast.FuncDecl, goFiles []*ast.File, info *types.Info) []swagen.ResponseInfo {
	var responses []swagen.ResponseInfo
	if fn.Body == nil {
		return responses
	}

	// First pass: collect all WriteHeader calls with their status codes
	statusCodes := findAllStatusCodes(fn)

	ast.Inspect(fn.Body, func(n ast.Node) bool {
		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}

		// Check for Chi-specific JSON methods
		if se, ok := call.Fun.(*ast.SelectorExpr); ok {
			if isChiJSONMethod(se.Sel.Name) {
				if len(call.Args) >= 2 {
					statusCode := resolveStatusCode(call.Args[0])
					if statusCode == 0 {
						return true
					}

					var responseType string
					var mapKeys map[string]string
					if ident, ok := call.Args[1].(*ast.Ident); ok {
						responseType = resolveVarTypeInFunc(fn, ident.Name, goFiles)
						if responseType == "" {
							responseType = ident.Name
						}
					} else if comp, ok := call.Args[1].(*ast.CompositeLit); ok {
						// Use go/types to resolve the real type
						if info != nil {
							if typ := info.Types[comp.Type].Type; typ != nil {
								fmt.Printf("DEBUG: composite literal type: %T %v\n", typ, typ)
								// Unwrap named types (e.g., chi.H)
								if named, ok := typ.(*types.Named); ok {
									typ = named.Underlying()
								}
								if mapType, ok := typ.(*types.Map); ok {
									responseType = typ.String() // canonical type name, e.g., map[string]interface{}
									mapKeys = extractMapKeysFromCompositeLit(comp, mapType, info)
								} else {
									responseType = typ.String()
								}
							}
						}
						if responseType == "" {
							responseType = getTypeName(comp.Type)
						}
					}

					if responseType != "" {
						responses = append(responses, swagen.ResponseInfo{
							StatusCode: statusCode,
							Type:       responseType,
							MediaType:  "application/json",
							MapKeys:    mapKeys,
						})
					}
				}
				return true
			}
		}

		// Check for standard Go json.NewEncoder().Encode() patterns
		if isJSONEncodeCall(call) {
			// Find the appropriate status code from collected status codes
			statusCode := findBestStatusCode(statusCodes, call.Pos())
			if statusCode == 0 {
				statusCode = 200 // default to 200 if not found
			}

			var responseType string
			var mapKeys map[string]string
			if ident, ok := call.Args[0].(*ast.Ident); ok {
				responseType = resolveVarTypeInFunc(fn, ident.Name, goFiles)
				if responseType == "" {
					responseType = ident.Name
				}
			} else if comp, ok := call.Args[0].(*ast.CompositeLit); ok {
				responseType = getTypeName(comp.Type)
				// Extract map keys for better error response schemas
				if info != nil {
					if typ := info.Types[comp.Type].Type; typ != nil {
						if mapType, ok := typ.(*types.Map); ok {
							mapKeys = extractMapKeysFromCompositeLit(comp, mapType, info)
						}
					}
				}
			}

			if responseType != "" {
				responses = append(responses, swagen.ResponseInfo{
					StatusCode: statusCode,
					Type:       responseType,
					MediaType:  "application/json",
					MapKeys:    mapKeys,
				})
			}
		}

		return true
	})

	return responses
}

// extractMapKeysFromCompositeLit extracts actual keys from map literals for better schema generation
func extractMapKeysFromCompositeLit(comp *ast.CompositeLit, mapType *types.Map, info *types.Info) map[string]string {
	mapKeys := make(map[string]string)
	valueType := mapType.Elem().String()

	for _, elt := range comp.Elts {
		if kv, ok := elt.(*ast.KeyValueExpr); ok {
			if key, ok := kv.Key.(*ast.BasicLit); ok && key.Kind == token.STRING {
				keyName := strings.Trim(key.Value, "\"")
				valType := getTypeName(kv.Value)
				if valType == "" {
					// For string literals, use "string" type
					if lit, ok := kv.Value.(*ast.BasicLit); ok && lit.Kind == token.STRING {
						valType = "string"
					} else if ident, ok := kv.Value.(*ast.Ident); ok {
						// For identifiers, try to resolve the type
						if info != nil {
							if obj := info.Uses[ident]; obj != nil {
								if obj.Type() != nil {
									valType = obj.Type().String()
								}
							}
						}
						// If we can't resolve the type, assume it's a string for common cases
						if valType == "" {
							valType = "string"
						}
					} else {
						valType = valueType
					}
				}

				// Normalize type names to avoid creating unnecessary schemas
				if valType == "string" || valType == "int" || valType == "bool" || valType == "float64" {
					// Keep primitive types as-is
				} else if strings.HasPrefix(valType, "string") {
					valType = "string"
				}

				mapKeys[keyName] = valType
			}
		}
	}

	return mapKeys
}

// findAllStatusCodes collects all WriteHeader calls with their status codes and positions
func findAllStatusCodes(fn *ast.FuncDecl) map[token.Pos]int {
	statusCodes := make(map[token.Pos]int)
	ast.Inspect(fn.Body, func(n ast.Node) bool {
		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}

		if se, ok := call.Fun.(*ast.SelectorExpr); ok {
			if se.Sel.Name == "WriteHeader" {
				if len(call.Args) > 0 {
					statusCode := resolveStatusCode(call.Args[0])
					if statusCode > 0 {
						statusCodes[call.Pos()] = statusCode
					}
				}
			}
		}
		return true
	})
	return statusCodes
}

// findBestStatusCode finds the most appropriate status code for a given position
func findBestStatusCode(statusCodes map[token.Pos]int, pos token.Pos) int {
	// Find the closest WriteHeader call before this position
	var bestCode int
	var bestPos token.Pos

	for codePos, code := range statusCodes {
		if codePos < pos && (bestPos == 0 || codePos > bestPos) {
			bestCode = code
			bestPos = codePos
		}
	}

	return bestCode
}

// isChiJSONMethod checks if a function name is a Chi JSON response method
func isChiJSONMethod(name string) bool {
	switch name {
	case "JSON", "WriteJSON", "Render":
		return true
	}
	return false
}

// isJSONEncodeCall checks if a call is json.NewEncoder().Encode()
func isJSONEncodeCall(call *ast.CallExpr) bool {
	if len(call.Args) == 0 {
		return false
	}

	// Check if it's a method call on json.NewEncoder()
	if se, ok := call.Fun.(*ast.SelectorExpr); ok {
		if se.Sel.Name == "Encode" {
			// Check if the receiver is json.NewEncoder()
			if callExpr, ok := se.X.(*ast.CallExpr); ok {
				if se2, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
					if se2.Sel.Name == "NewEncoder" {
						// Check if it's from json package
						if ident, ok := se2.X.(*ast.Ident); ok {
							return ident.Name == "json"
						}
					}
				}
			}
		}
	}
	return false
}

// --- Chi-specific Builder Methods ---

func (b *ParsedRouteBuilder) ChiRequestBody(decl *ast.FuncDecl) *ParsedRouteBuilder {
	if decl == nil {
		return b
	}
	requestType := extractChiRequestBodyType(decl)
	if requestType != "" {
		b.route.RequestType = requestType
		b.route.RequestSource = "body"
	}
	return b
}

func (b *ParsedRouteBuilder) ChiResponses(decl *ast.FuncDecl, goFiles []*ast.File) *ParsedRouteBuilder {
	if decl == nil {
		return b
	}
	b.route.ResponseTypes = extractChiResponseTypes(decl, goFiles, b.info)
	return b
}
