package parser

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"regexp"
	"strconv"
	"strings"

	"github.com/ehabterra/swagen"
)

// --- Event System (Observer Pattern) ---
type ParseEvent string

const (
	EventRouteFound ParseEvent = "route_found"
)

type EventListener func(event ParseEvent, route *swagen.ParsedRoute)

// --- Chain of Responsibility for Strategies ---
type RouteStrategy interface {
	TryParse(node ast.Node, fset *token.FileSet, funcMap map[string]*ast.FuncDecl, goFiles []*ast.File, next RouteStrategy, info *types.Info) (*swagen.ParsedRoute, bool)
}

type StrategyChain struct {
	strategies []RouteStrategy
}

func (c *StrategyChain) TryParse(node ast.Node, fset *token.FileSet, funcMap map[string]*ast.FuncDecl, goFiles []*ast.File, _ RouteStrategy, info *types.Info) (*swagen.ParsedRoute, bool) {
	return c.tryParseAt(0, node, fset, funcMap, goFiles, info)
}
func (c *StrategyChain) tryParseAt(i int, node ast.Node, fset *token.FileSet, funcMap map[string]*ast.FuncDecl, goFiles []*ast.File, info *types.Info) (*swagen.ParsedRoute, bool) {
	if i >= len(c.strategies) {
		return nil, false
	}
	return c.strategies[i].TryParse(node, fset, funcMap, goFiles, &strategyChainNext{c, i + 1}, info)
}

type strategyChainNext struct {
	chain *StrategyChain
	index int
}

func (n *strategyChainNext) TryParse(node ast.Node, fset *token.FileSet, funcMap map[string]*ast.FuncDecl, goFiles []*ast.File, _ RouteStrategy, info *types.Info) (*swagen.ParsedRoute, bool) {
	return n.chain.tryParseAt(n.index, node, fset, funcMap, goFiles, info)
}

// --- GinCallExprStrategy (example strategy) ---

var ginParamRe = regexp.MustCompile(`:([a-zA-Z0-9_]+)`)

func convertGinPathToOpenAPI(path string) string {
	return ginParamRe.ReplaceAllString(path, `{$1}`)
}

type GinCallExprStrategy struct{}

func (s *GinCallExprStrategy) TryParse(node ast.Node, fset *token.FileSet, funcMap map[string]*ast.FuncDecl, goFiles []*ast.File, next RouteStrategy, info *types.Info) (*swagen.ParsedRoute, bool) {
	call, ok := node.(*ast.CallExpr)
	if !ok {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	se, ok := call.Fun.(*ast.SelectorExpr)
	if !ok {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}

	method := se.Sel.Name
	if !isGinHTTPMethod(method) {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}

	if len(call.Args) < 2 {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	pathLit, ok := call.Args[0].(*ast.BasicLit)
	if !ok || pathLit.Kind != token.STRING {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	path := strings.Trim(pathLit.Value, "\"")

	handlerName := getHandlerName(call.Args[1])
	if handlerName == "" {
		return next.TryParse(node, fset, funcMap, goFiles, next, info)
	}
	handlerFunc := funcMap[handlerName]

	builder := NewParsedRouteBuilder(info)
	route := builder.Method(method).
		Path(path).
		Handler(handlerName, handlerFunc).
		RequestBody(handlerFunc).
		Responses(handlerFunc, goFiles).
		Position(fset, call.Pos()).
		Build()

	return &route, true
}

// --- Builder Pattern for ParsedRoute ---
type ParsedRouteBuilder struct {
	route swagen.ParsedRoute
	info  *types.Info
}

func NewParsedRouteBuilder(info *types.Info) *ParsedRouteBuilder {
	return &ParsedRouteBuilder{info: info}
}

func (b *ParsedRouteBuilder) Method(method string) *ParsedRouteBuilder {
	b.route.Method = strings.ToUpper(method)
	return b
}

func (b *ParsedRouteBuilder) Path(path string) *ParsedRouteBuilder {
	b.route.Path = convertGinPathToOpenAPI(path)
	return b
}

func (b *ParsedRouteBuilder) Handler(name string, decl *ast.FuncDecl) *ParsedRouteBuilder {
	b.route.Handler = name
	b.route.HandlerFunc = decl
	return b
}

func (b *ParsedRouteBuilder) RequestBody(decl *ast.FuncDecl) *ParsedRouteBuilder {
	if decl == nil {
		return b
	}
	requestType := extractGinRequestBodyType(decl)
	if requestType != "" {
		b.route.RequestType = requestType
		b.route.RequestSource = "body"
	}
	return b
}

func (b *ParsedRouteBuilder) Responses(decl *ast.FuncDecl, goFiles []*ast.File) *ParsedRouteBuilder {
	if decl == nil {
		return b
	}
	b.route.ResponseTypes = extractGinResponseTypes(decl, goFiles, b.info)
	return b
}

func (b *ParsedRouteBuilder) Position(fset *token.FileSet, pos token.Pos) *ParsedRouteBuilder {
	position := fset.Position(pos)
	b.route.File = position.Filename
	b.route.Line = position.Line
	return b
}

func (b *ParsedRouteBuilder) Build() swagen.ParsedRoute {
	return b.route
}

// --- GinParser with Event System and Chain of Responsibility ---
type GinParser struct {
	chain     *StrategyChain
	listeners []EventListener
	info      *types.Info // for type resolution
}

func NewGinParserWithTypes(strategies []RouteStrategy, info *types.Info, listeners ...EventListener) *GinParser {
	return &GinParser{
		chain:     &StrategyChain{strategies: strategies},
		listeners: listeners,
		info:      info,
	}
}

func DefaultGinParserWithTypes(info *types.Info) *GinParser {
	return NewGinParserWithTypes(
		[]RouteStrategy{
			&GinCallExprStrategy{},
			// Add more strategies here
		},
		info,
	)
}

func (p *GinParser) AddListener(listener EventListener) {
	p.listeners = append(p.listeners, listener)
}

func (p *GinParser) Parse(fset *token.FileSet, files []*ast.File) ([]swagen.ParsedRoute, error) {
	funcMap := buildFuncMap(files)
	var routes []swagen.ParsedRoute

	for _, file := range files {
		ast.Inspect(file, func(n ast.Node) bool {
			if route, ok := p.chain.TryParse(n, fset, funcMap, files, nil, p.info); ok {
				routes = append(routes, *route)
				for _, l := range p.listeners {
					l(EventRouteFound, route)
				}
				return false
			}
			return true
		})
	}
	return routes, nil
}

// --- Helpers (specific to Gin) ---
func isGinHTTPMethod(method string) bool {
	switch method {
	case "GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD":
		return true
	}
	return false
}

// extractGinRequestBodyType inspects a function body to find the type of a bound variable.
// This is specific to Gin's binding methods.
func extractGinRequestBodyType(fn *ast.FuncDecl) string {
	if fn.Body == nil {
		return ""
	}

	var boundVarName string
	ast.Inspect(fn.Body, func(n ast.Node) bool {
		if boundVarName != "" {
			return false
		}
		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}
		se, ok := call.Fun.(*ast.SelectorExpr)
		if !ok || !isGinBindingMethod(se.Sel.Name) {
			return true
		}

		if len(call.Args) > 0 {
			if unary, ok := call.Args[0].(*ast.UnaryExpr); ok && unary.Op == token.AND {
				if ident, ok := unary.X.(*ast.Ident); ok {
					boundVarName = ident.Name
					return false
				}
			}
		}
		return true
	})

	if boundVarName == "" {
		return ""
	}

	var varType string
	ast.Inspect(fn.Body, func(n ast.Node) bool {
		if varType != "" {
			return false
		}
		decl, ok := n.(*ast.DeclStmt)
		if !ok {
			return true
		}
		genDecl, ok := decl.Decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.VAR {
			return true
		}
		for _, spec := range genDecl.Specs {
			if vspec, ok := spec.(*ast.ValueSpec); ok {
				for _, name := range vspec.Names {
					if name.Name == boundVarName {
						if typeName := getTypeName(vspec.Type); typeName != "" {
							varType = typeName
							return false
						}
					}
				}
			}
		}
		return true
	})

	return varType
}

// isGinBindingMethod checks if a function name is a common Gin binding method.
func isGinBindingMethod(name string) bool {
	switch name {
	case "ShouldBindJSON", "BindJSON", "ShouldBind", "Bind":
		return true
	}
	return false
}

// Patch extractGinResponseTypes to use the canonical type name from go/types
func extractGinResponseTypes(fn *ast.FuncDecl, goFiles []*ast.File, info *types.Info) []swagen.ResponseInfo {
	var responses []swagen.ResponseInfo
	if fn.Body == nil {
		return responses
	}

	ast.Inspect(fn.Body, func(n ast.Node) bool {
		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}

		se, ok := call.Fun.(*ast.SelectorExpr)
		if !ok {
			return true
		}

		if se.Sel.Name != "JSON" {
			return true
		}

		if len(call.Args) < 2 {
			return true
		}

		statusCode := resolveStatusCode(call.Args[0])
		if statusCode == 0 {
			return true
		}

		var responseType string
		var mapKeys map[string]string
		if ident, ok := call.Args[1].(*ast.Ident); ok {
			responseType = resolveVarTypeInFunc(fn, ident.Name, goFiles)
			if responseType == "" {
				responseType = ident.Name
			}
		} else if comp, ok := call.Args[1].(*ast.CompositeLit); ok {
			// Use go/types to resolve the real type
			if info != nil {
				if typ := info.Types[comp.Type].Type; typ != nil {
					fmt.Printf("DEBUG: composite literal type: %T %v\n", typ, typ)
					// Unwrap named types (e.g., gin.H)
					if named, ok := typ.(*types.Named); ok {
						typ = named.Underlying()
					}
					if mapType, ok := typ.(*types.Map); ok {
						responseType = typ.String() // canonical type name, e.g., map[string]interface{}
						mapKeys = make(map[string]string)
						valueType := mapType.Elem().String()
						for _, elt := range comp.Elts {
							if kv, ok := elt.(*ast.KeyValueExpr); ok {
								if key, ok := kv.Key.(*ast.BasicLit); ok && key.Kind == token.STRING {
									keyName := strings.Trim(key.Value, "\"")
									valType := getTypeName(kv.Value)
									if valType == "" {
										valType = valueType
										if valType == "" {
											valType = "string"
										}
									}
									mapKeys[keyName] = valType
								}
							}
						}
					}
				}
			}
			if responseType == "" {
				responseType = getTypeName(comp.Type)
			}
		} else {
			responseType = getTypeName(call.Args[1])
		}

		for _, r := range responses {
			if r.StatusCode == statusCode {
				return true
			}
		}

		responses = append(responses, swagen.ResponseInfo{
			StatusCode: statusCode,
			Type:       responseType,
			MediaType:  "application/json",
			MapKeys:    mapKeys,
		})
		return true
	})

	return responses
}

func resolveStatusCode(expr ast.Expr) int {
	switch e := expr.(type) {
	case *ast.BasicLit:
		if e.Kind == token.INT {
			if val, err := strconv.Atoi(e.Value); err == nil {
				return val
			}
		}
	case *ast.SelectorExpr:
		// Handle http.StatusOK, etc.
		if pkg, ok := e.X.(*ast.Ident); ok && pkg.Name == "http" {
			switch e.Sel.Name {
			case "StatusOK":
				return 200
			case "StatusCreated":
				return 201
			case "StatusAccepted":
				return 202
			case "StatusNoContent":
				return 204
			case "StatusBadRequest":
				return 400
			case "StatusUnauthorized":
				return 401
			case "StatusForbidden":
				return 403
			case "StatusNotFound":
				return 404
			}
		}
	}
	return 0
}

// NewGinParserForTest creates a GinParser with type information for testing
func NewGinParserForTest(files []*ast.File) (*GinParser, error) {
	// Create types.Info to collect type information
	info := &types.Info{
		Types:      make(map[ast.Expr]types.TypeAndValue),
		Defs:       make(map[*ast.Ident]types.Object),
		Uses:       make(map[*ast.Ident]types.Object),
		Implicits:  make(map[ast.Node]types.Object),
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
		Scopes:     make(map[ast.Node]*types.Scope),
	}

	// For tests, we'll skip type checking since we might not have all dependencies
	// and the parser can work with minimal type information
	return DefaultGinParserWithTypes(info), nil
}
